// <copyright file="CompiledClassFactory.cs" company="Tom Luppi">
//     Copyright (c) Tom Luppi.  All rights reserved.
// </copyright>

namespace CompiledDefinitionSourceGenerator
{
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    /// <summary>
    /// Factory which creates the compiled source file.
    /// </summary>
    internal static class CompiledClassFactory
    {
        /// <summary>
        /// The usings in the class.
        /// </summary>
        private const string Usings = @"
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using LegendsGenerator.Contracts;
    using LegendsGenerator.Contracts.Compiler;
    using LegendsGenerator.Contracts.Definitions;
    using LegendsGenerator.Contracts.Definitions.Events;";

        /// <summary>
        /// Generates a comparible Compiled Definition from the class info.
        /// </summary>
        /// <param name="classInfo">The class info to generate.</param>
        /// <returns>The class's C# code.</returns>
        public static string Generate(ClassInfo classInfo)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine($"namespace {classInfo.Namespace}");
            sb.AppendLine("{");
            sb.AppendLine(Usings);
            sb.AppendLine($"    {classInfo.Accesibility} partial class {classInfo.TypeName}");
            sb.AppendLine("    {");
            sb.AppendLine(FieldDefinitions(classInfo));
            sb.AppendLine(CompileMethod(classInfo));
            sb.AppendLine(AttachMethod(classInfo));

            bool classAddParams = 
                classInfo.AdditionalParametersForMethods.Any(x => x.Equals(ClassInfo.AdditionalParamtersForClassMethod));

            foreach (var prop in classInfo.CompiledProps)
            {
                sb.AppendLine(EvalConditionMethod(prop, classInfo.AdditionalParametersForMethods, classAddParams));
            }

            foreach (var prop in classInfo.CompiledDictionaryProps)
            {
                sb.AppendLine(EvalDictionaryConditionMethod(prop, classInfo.AdditionalParametersForMethods, classAddParams));
            }

            foreach (var prop in classInfo.CompiledProps)
            {
                sb.AppendLine(GetParametersMethod(prop, classInfo.AdditionalParametersForMethods, classAddParams));
            }

            foreach (var prop in classInfo.CompiledDictionaryProps)
            {
                sb.AppendLine(GetParametersMethod(prop, classInfo.AdditionalParametersForMethods, classAddParams));
            }

            sb.AppendLine("}");
            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Gets the field definitions on this class.
        /// </summary>
        /// <param name="classInfo">The class info.</param>
        /// <returns>All nessesary field definions.</returns>
        private static string FieldDefinitions(ClassInfo classInfo)
        {
            StringBuilder sb = new StringBuilder();

            foreach (var prop in classInfo.CompiledProps)
            {
                sb.AppendLine($"private Lazy<ICompiledCondition<{prop.ReturnType}>> compiledCondition{prop.Name};");
            }

            foreach (var prop in classInfo.CompiledDictionaryProps)
            {
                sb.AppendLine($"private IDictionary<string, Lazy<ICompiledCondition<{prop.ReturnType}>>> compiledCondition{prop.Name} =");
                sb.AppendLine($"    new Dictionary<string, Lazy<ICompiledCondition<{prop.ReturnType}>>>();");
            }

            return sb.ToString();
        }

        private static string AttachMethod(ClassInfo classInfo)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("public override void Attach(IConditionCompiler compiler) {");
            sb.AppendLine("base.Attach(compiler);");

            foreach (var prop in classInfo.CompiledProps)
            {
                sb.AppendLine($"this.compiledCondition{prop.Name} = ");
                string type = prop.AsFormattedText ? "AsFormattedText" : $"AsSimple<{prop.ReturnType}>";
                sb.AppendLine($"   new Lazy<ICompiledCondition<{prop.ReturnType}>>(() => this.Compiler.{type}(this.{prop.Name}, this.GetParameters{prop.Name}()));");
            }

            foreach (var prop in classInfo.CompiledDictionaryProps)
            {
                string type = prop.AsFormattedText ? "AsFormattedText" : $"AsSimple<{prop.ReturnType}>";
                sb.AppendLine($"foreach (var entry in this.{prop.Name})");
                sb.AppendLine("{");
                sb.AppendLine($"this.compiledCondition{prop.Name}[entry.Key] = ");
                sb.AppendLine($"   new Lazy<ICompiledCondition<{prop.ReturnType}>>(() => this.Compiler.{type}(this.{prop.Name}[entry.Key], this.GetParameters{prop.Name}()));");
                sb.AppendLine("}");
            }

            foreach (var prop in classInfo.DefinitionProps)
            {
                sb.AppendLine($"this.{prop}?.Attach(compiler);");
            }

            foreach (var prop in classInfo.DefinitionArrayProps)
            {
                sb.AppendLine($"foreach (var value in this.{prop})");
                sb.AppendLine("{");
                sb.AppendLine($"   value.Attach(compiler);");
                sb.AppendLine("}");
            }

            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Creates the method which activates all Lazy fields so compile everything.
        /// </summary>
        /// <param name="classInfo">The class info.</param>
        /// <returns>The method, in string form.</returns>
        private static string CompileMethod(ClassInfo classInfo)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine($"public override void Compile()");
            sb.AppendLine("{");
            sb.AppendLine("base.Compile();");

            foreach (PropertyInfo prop in classInfo.CompiledProps)
            {
                sb.AppendLine($"_ = this.compiledCondition{prop.Name}.Value;");
            }

            foreach (PropertyInfo prop in classInfo.CompiledDictionaryProps)
            {
                sb.AppendLine($"this.compiledCondition{prop.Name}.ToList().ForEach(x => _ = x.Value.Value);");
            }

            foreach (var prop in classInfo.DefinitionProps)
            {
                sb.AppendLine($"this.{prop}?.Compile();");
            }

            foreach (var prop in classInfo.DefinitionArrayProps)
            {
                sb.AppendLine($"foreach (var value in this.{prop})");
                sb.AppendLine("{");
                sb.AppendLine($"   value.Compile();");
                sb.AppendLine("}");
            }

            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Creates the method which runs the condition evalulate method.
        /// </summary>
        /// <param name="info">The property info.</param>
        /// <param name="additionParameterMethods">The list of additional parameter methods.</param>
        /// <param name="classAddParams">True if the class has additional parameters method.</param>
        /// <returns>The method, in string form.</returns>
        private static string EvalConditionMethod(
            PropertyInfo info, 
            IReadOnlyCollection<string> additionParameterMethods, 
            bool classAddParams)
        {
            string? matchingAdditionalParamtersMethod =
                additionParameterMethods.FirstOrDefault(x => x.Equals($"{ClassInfo.AdditionalParamtersMethodPrefix}{info.Name}"));

            List<string> allParameters = new List<string>() { "Random rdm" };
            allParameters.AddRange(info.Variables.Select(v => $"BaseThing {v}").ToList());

            if (matchingAdditionalParamtersMethod != null || classAddParams)
            {
                allParameters.Add("IDictionary<string, BaseThing> additionalParameters");
            }

            string parametersList = string.Join(", ", allParameters);

            StringBuilder sb = new StringBuilder();
            sb.AppendLine($"public {info.ReturnType} Eval{info.Name}({parametersList})");
            sb.AppendLine("{");
            sb.AppendLine(@"IDictionary<string, BaseThing> param = new Dictionary<string, BaseThing>() {");

            foreach (var parameter in info.Variables)
            {
                sb.AppendLine($"{{ {SurroundInQuotes(parameter)}, {parameter} }}");
            }

            sb.AppendLine("};");

            if (matchingAdditionalParamtersMethod != null || classAddParams)
            {
                sb.AppendLine(@"
                    foreach(var additionalParameter in additionalParameters)
                    {
                        param[additionalParameter.Key] = additionalParameter.Value;
                    }");
            }

            sb.AppendLine($"return this.compiledCondition{info.Name}.Value.Evaluate(rdm, param);");
            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Creates the method which runs the condition evalulate method.
        /// </summary>
        /// <param name="info">The property info.</param>
        /// <param name="additionParameterMethods">The list of additional parameter methods.</param>
        /// <param name="classAddParams">True if the class has additional parameters method.</param>
        /// <returns>The method, in string form.</returns>
        private static string EvalDictionaryConditionMethod(
            PropertyInfo info, 
            IReadOnlyCollection<string> additionParameterMethods, 
            bool classAddParams)
        {
            string? matchingAdditionalParamtersMethod =
                additionParameterMethods.FirstOrDefault(x => x.Equals($"{ClassInfo.AdditionalParamtersMethodPrefix}{info.Name}"));
            List<string> allParameters = new List<string>() { "string key", "Random rdm" };
            allParameters.AddRange(info.Variables.Select(v => $"BaseThing {v}").ToList());

            if (matchingAdditionalParamtersMethod != null || classAddParams)
            {
                allParameters.Add("IDictionary<string, BaseThing> additionalParameters");
            }

            string parametersList = string.Join(", ", allParameters);

            StringBuilder sb = new StringBuilder();
            sb.AppendLine($"public {info.ReturnType} Eval{info.Name}({parametersList})");
            sb.AppendLine("{");
            sb.AppendLine(@"IDictionary<string, BaseThing> param = new Dictionary<string, BaseThing>() {");

            foreach (var parameter in info.Variables)
            {
                sb.AppendLine($"{{ {SurroundInQuotes(parameter)}, {parameter} }}");
            }

            sb.AppendLine("};");

            if (matchingAdditionalParamtersMethod != null)
            {
                sb.AppendLine(@"
                    foreach(var additionalParameter in additionalParameters)
                    {
                        param[additionalParameter.Key] = additionalParameter.Value;
                    }");
            }

            sb.AppendLine($"return this.compiledCondition{info.Name}[key].Value.Evaluate(rdm, param);");
            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Constructs a method which gets the parameters lsit for the specified property.
        /// </summary>
        /// <param name="info">The property info.</param>
        /// <param name="additionParameterMethods">The list of methods which return addition parameter names.</param>
        /// <param name="classAddParams">True if the class has additional parameters method.</param>
        /// <returns>A method, in string form</returns>
        private static string GetParametersMethod(
            PropertyInfo info, 
            IReadOnlyCollection<string> additionParameterMethods, 
            bool classAddParams)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine($"private IList<string> GetParameters{info.Name}()");
            sb.AppendLine("{");
            sb.AppendLine($"List<string> parameters = new List<string> {{ {string.Join(", ", info.Variables.Select(SurroundInQuotes))} }};");

            string? matchingAdditionalParamtersMethod =
                additionParameterMethods.FirstOrDefault(x => x.Equals($"{ClassInfo.AdditionalParamtersMethodPrefix}{info.Name}"));

            if (matchingAdditionalParamtersMethod != null)
            {
                sb.AppendLine($"parameters.AddRange(this.{matchingAdditionalParamtersMethod}());");
            }

            if (classAddParams)
            {
                sb.AppendLine($"parameters.AddRange(this.{ClassInfo.AdditionalParamtersForClassMethod}());");
            }

            sb.AppendLine("return parameters;\n}");

            return sb.ToString();
        }

        /// <summary>
        /// Surrounds the input string in quotes.
        /// </summary>
        /// <param name="input">The input string.</param>
        /// <returns>The string, but in quotes.</returns>
        private static string SurroundInQuotes(string input)
        {
            return "\"" + input + "\"";
        }
    }
}

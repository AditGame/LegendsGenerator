// <copyright file="CompiledClassFactory.cs" company="Tom Luppi">
//     Copyright (c) Tom Luppi.  All rights reserved.
// </copyright>

namespace CompiledDefinitionSourceGenerator
{
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    /// <summary>
    /// Factory which creates the compiled source file.
    /// </summary>
    internal static class CompiledClassFactory
    {
        /// <summary>
        /// The usings in the class.
        /// </summary>
        private const string Usings = @"
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using LegendsGenerator.Contracts;
    using LegendsGenerator.Contracts.Compiler;
    using LegendsGenerator.Contracts.Definitions;
    using LegendsGenerator.Contracts.Definitions.Events;";

        /// <summary>
        /// Generates a comparible Compiled Definition from the class info.
        /// </summary>
        /// <param name="classInfo">The class info to generate.</param>
        /// <returns>The class's C# code.</returns>
        public static string Generate(ClassInfo classInfo)
        {
            bool additionalParametersForClassDefined =
                classInfo.AdditionalParametersForMethods.Any(x => x.Equals(ClassInfo.AdditionalParamtersForClassMethod));

            bool classAddParams = additionalParametersForClassDefined || classInfo.UsesAdditionalParametersForHoldingClass;

            StringBuilder sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine($"namespace {classInfo.Namespace}");
            sb.AppendLine("{");
            sb.AppendLine(Usings);
            sb.AppendLine($"    {classInfo.Accesibility} partial class {classInfo.TypeName}");
            sb.AppendLine("    {");
            sb.AppendLine(@"
private ICompiledCondition<T> CreateCondition<T>(string condition, bool formattedText, bool complex, IList<string> parameters)
{
    if (complex)
    {
        return this.Compiler.AsComplex<T>(condition, parameters);
    }
    else if (formattedText)
    {
        return this.Compiler.AsFormattedText(condition, parameters) as ICompiledCondition<T>;
    }
    else
    {
        return this.Compiler.AsSimple<T>(condition, parameters);
    }
}");
            sb.AppendLine(FieldDefinitions(classInfo));
            sb.AppendLine(CompileMethod(classInfo));
            sb.AppendLine(AttachMethod(classInfo));
            sb.AppendLine(CombinedAdditionalParametersForClass(classInfo, additionalParametersForClassDefined));

            if (classInfo.UsesAdditionalParametersForHoldingClass)
            {
                sb.AppendLine(AttachUpstreamParametersMethod());
            }

            foreach (var prop in classInfo.CompiledProps)
            {
                sb.AppendLine(IsComplexProperty(prop));
            }

            foreach (var prop in classInfo.CompiledDictionaryProps)
            {
                sb.AppendLine(IsComplexProperty(prop));
            }

            foreach (var prop in classInfo.CompiledProps)
            {
                sb.AppendLine(EvalConditionMethod(prop, classInfo.AdditionalParametersForMethods, classAddParams));
            }

            foreach (var prop in classInfo.CompiledDictionaryProps)
            {
                sb.AppendLine(EvalDictionaryConditionMethod(prop, classInfo.AdditionalParametersForMethods, classAddParams));
            }

            foreach (var prop in classInfo.CompiledProps)
            {
                sb.AppendLine(GetParametersMethod(prop, classInfo.AdditionalParametersForMethods, classAddParams));
            }

            foreach (var prop in classInfo.CompiledDictionaryProps)
            {
                sb.AppendLine(GetParametersMethod(prop, classInfo.AdditionalParametersForMethods, classAddParams));
            }

            sb.AppendLine("}");
            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Gets the field definitions on this class.
        /// </summary>
        /// <param name="classInfo">The class info.</param>
        /// <returns>All nessesary field definions.</returns>
        private static string FieldDefinitions(ClassInfo classInfo)
        {
            StringBuilder sb = new StringBuilder();

            if (classInfo.UsesAdditionalParametersForHoldingClass)
            {
                sb.AppendLine("private Func<IList<string>>? upstreamAdditionalParametersMethod;");
            }

            foreach (var prop in classInfo.CompiledProps)
            {
                sb.AppendLine($"private Lazy<ICompiledCondition<{prop.ReturnType}>> compiledCondition{prop.Name};");
            }

            foreach (var prop in classInfo.CompiledDictionaryProps)
            {
                sb.AppendLine($"private IDictionary<string, Lazy<ICompiledCondition<{prop.ReturnType}>>> compiledCondition{prop.Name} =");
                sb.AppendLine($"    new Dictionary<string, Lazy<ICompiledCondition<{prop.ReturnType}>>>();");
            }

            return sb.ToString();
        }

        /// <summary>
        /// Creates a class which combined the class-wide additional parameters class and the upstream parameters.
        /// </summary>
        /// <param name="classInfo">The class info.</param>
        /// <param name="classAddParams">If the class has a class-wide additional parameters method.</param>
        /// <returns>All nessesary field definions.</returns>
        private static string CombinedAdditionalParametersForClass(ClassInfo classInfo, bool classAddParams)
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine($"private IList<string> Combined{ClassInfo.AdditionalParamtersForClassMethod}()");
            sb.AppendLine("{");
            sb.AppendLine($"List<string> addParams = new List<string>();");

            if (classAddParams)
            {
                sb.AppendLine($"addParams.AddRange(this.{ClassInfo.AdditionalParamtersForClassMethod}());");
            }

            if (classInfo.UsesAdditionalParametersForHoldingClass)
            {
                sb.AppendLine($"addParams.AddRange(this.upstreamAdditionalParametersMethod?.Invoke() ?? new List<string>());");
            }

            sb.AppendLine("return addParams;");
            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Generates the method which allows attaching the upstream parameters method.
        /// </summary>
        /// <returns>The mthod in string form.</returns>
        private static string AttachUpstreamParametersMethod()
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine($"public new void AttachUpStreamParams(Func<IList<string>> func)");
            sb.AppendLine("{");
            sb.AppendLine($"this.upstreamAdditionalParametersMethod = func;");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static string AttachMethod(ClassInfo classInfo)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("public override void Attach(IConditionCompiler compiler) {");
            sb.AppendLine("base.Attach(compiler);");

            foreach (var prop in classInfo.CompiledProps)
            {
                sb.AppendLine($"this.compiledCondition{prop.Name} = ");
                sb.AppendLine($"   new Lazy<ICompiledCondition<{prop.ReturnType}>>(() => this.CreateCondition<{prop.ReturnType}>(this.{prop.Name}, {prop.AsFormattedText.ToString().ToLower()}, this.{prop.Name}_IsComplex, this.GetParameters{prop.Name}()));");
            }

            foreach (var prop in classInfo.CompiledDictionaryProps)
            {
                sb.AppendLine($"foreach (var entry in this.{prop.Name})");
                sb.AppendLine("{");
                sb.AppendLine($"this.compiledCondition{prop.Name}[entry.Key] = ");
                sb.AppendLine($"   new Lazy<ICompiledCondition<{prop.ReturnType}>>(() => this.CreateCondition<{prop.ReturnType}>(this.{prop.Name}[entry.Key], {prop.AsFormattedText.ToString().ToLower()}, this.{prop.Name}_IsComplex, this.GetParameters{prop.Name}()));");
                sb.AppendLine("}");
            }

            foreach (var prop in classInfo.DefinitionProps)
            {
                sb.AppendLine($"this.{prop.Name}?.Attach(compiler);");

                if (prop.UsesAdditionalParametersForHoldingClass)
                {
                    sb.AppendLine($"this.{prop.Name}?.AttachUpStreamParams(this.Combined{ClassInfo.AdditionalParamtersForClassMethod});");
                }
            }

            foreach (var prop in classInfo.DefinitionArrayProps)
            {
                sb.AppendLine($"foreach (var value in this.{prop.Name})");
                sb.AppendLine("{");
                sb.AppendLine($"    value.Attach(compiler);");

                if (prop.UsesAdditionalParametersForHoldingClass)
                {
                    sb.AppendLine($"    value.AttachUpStreamParams(this.Combined{ClassInfo.AdditionalParamtersForClassMethod});");
                }
                sb.AppendLine("}");
            }

            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Creates the method which activates all Lazy fields so compile everything.
        /// </summary>
        /// <param name="classInfo">The class info.</param>
        /// <returns>The method, in string form.</returns>
        private static string CompileMethod(ClassInfo classInfo)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine($"public override void Compile()");
            sb.AppendLine("{");
            sb.AppendLine("base.Compile();");

            foreach (PropertyInfo prop in classInfo.CompiledProps)
            {
                sb.AppendLine($"_ = this.compiledCondition{prop.Name}.Value;");
            }

            foreach (PropertyInfo prop in classInfo.CompiledDictionaryProps)
            {
                sb.AppendLine($"this.compiledCondition{prop.Name}.ToList().ForEach(x => _ = x.Value.Value);");
            }

            foreach (var prop in classInfo.DefinitionProps)
            {
                sb.AppendLine($"this.{prop.Name}?.Compile();");
            }

            foreach (var prop in classInfo.DefinitionArrayProps)
            {
                sb.AppendLine($"foreach (var value in this.{prop.Name})");
                sb.AppendLine("{");
                sb.AppendLine($"   value.Compile();");
                sb.AppendLine("}");
            }

            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Generates the property which decides if a compiled property is complex.
        /// </summary>
        /// <returns>The method in string form.</returns>
        private static string IsComplexProperty(PropertyInfo info)
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine($"public bool {info.Name}_IsComplex {{ get; set; }}");

            return sb.ToString();
        }

        /// <summary>
        /// Creates the method which runs the condition evalulate method.
        /// </summary>
        /// <param name="info">The property info.</param>
        /// <param name="additionParameterMethods">The list of additional parameter methods.</param>
        /// <param name="classAddParams">True if the class has additional parameters method.</param>
        /// <returns>The method, in string form.</returns>
        private static string EvalConditionMethod(
            PropertyInfo info, 
            IReadOnlyCollection<string> additionParameterMethods, 
            bool classAddParams)
        {
            string? matchingAdditionalParamtersMethod =
                additionParameterMethods.FirstOrDefault(x => x.Equals($"{ClassInfo.AdditionalParamtersMethodPrefix}{info.Name}"));

            List<string> allParameters = new List<string>() { "Random rdm" };
            allParameters.AddRange(info.Variables.Select(v => $"BaseThing {v}").ToList());

            if (matchingAdditionalParamtersMethod != null || classAddParams)
            {
                allParameters.Add("IDictionary<string, BaseThing> additionalParameters");
            }

            string parametersList = string.Join(", ", allParameters);

            StringBuilder sb = new StringBuilder();
            sb.AppendLine($"public {info.ReturnType} Eval{info.Name}({parametersList})");
            sb.AppendLine("{");
            sb.AppendLine(@"IDictionary<string, BaseThing> param = new Dictionary<string, BaseThing>() {");

            foreach (var parameter in info.Variables)
            {
                sb.AppendLine($"{{ {SurroundInQuotes(parameter)}, {parameter} }}");
            }

            sb.AppendLine("};");

            if (matchingAdditionalParamtersMethod != null || classAddParams)
            {
                sb.AppendLine(@"
                    foreach(var additionalParameter in additionalParameters)
                    {
                        param[additionalParameter.Key] = additionalParameter.Value;
                    }");
            }

            sb.AppendLine($"return this.compiledCondition{info.Name}.Value.Evaluate(rdm, param);");
            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Creates the method which runs the condition evalulate method.
        /// </summary>
        /// <param name="info">The property info.</param>
        /// <param name="additionParameterMethods">The list of additional parameter methods.</param>
        /// <param name="classAddParams">True if the class has additional parameters method.</param>
        /// <returns>The method, in string form.</returns>
        private static string EvalDictionaryConditionMethod(
            PropertyInfo info, 
            IReadOnlyCollection<string> additionParameterMethods, 
            bool classAddParams)
        {
            string? matchingAdditionalParamtersMethod =
                additionParameterMethods.FirstOrDefault(x => x.Equals($"{ClassInfo.AdditionalParamtersMethodPrefix}{info.Name}"));
            List<string> allParameters = new List<string>() { "string key", "Random rdm" };
            allParameters.AddRange(info.Variables.Select(v => $"BaseThing {v}").ToList());

            if (matchingAdditionalParamtersMethod != null || classAddParams)
            {
                allParameters.Add("IDictionary<string, BaseThing> additionalParameters");
            }

            string parametersList = string.Join(", ", allParameters);

            StringBuilder sb = new StringBuilder();
            sb.AppendLine($"public {info.ReturnType} Eval{info.Name}({parametersList})");
            sb.AppendLine("{");
            sb.AppendLine(@"IDictionary<string, BaseThing> param = new Dictionary<string, BaseThing>() {");

            foreach (var parameter in info.Variables)
            {
                sb.AppendLine($"{{ {SurroundInQuotes(parameter)}, {parameter} }}");
            }

            sb.AppendLine("};");

            if (matchingAdditionalParamtersMethod != null)
            {
                sb.AppendLine(@"
                    foreach(var additionalParameter in additionalParameters)
                    {
                        param[additionalParameter.Key] = additionalParameter.Value;
                    }");
            }

            sb.AppendLine($"return this.compiledCondition{info.Name}[key].Value.Evaluate(rdm, param);");
            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Constructs a method which gets the parameters lsit for the specified property.
        /// </summary>
        /// <param name="info">The property info.</param>
        /// <param name="additionParameterMethods">The list of methods which return addition parameter names.</param>
        /// <param name="classAddParams">True if the class has additional parameters method.</param>
        /// <returns>A method, in string form</returns>
        private static string GetParametersMethod(
            PropertyInfo info, 
            IReadOnlyCollection<string> additionParameterMethods, 
            bool classAddParams)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine($"private IList<string> GetParameters{info.Name}()");
            sb.AppendLine("{");
            sb.AppendLine($"List<string> parameters = new List<string> {{ {string.Join(", ", info.Variables.Select(SurroundInQuotes))} }};");

            string? matchingAdditionalParamtersMethod =
                additionParameterMethods.FirstOrDefault(x => x.Equals($"{ClassInfo.AdditionalParamtersMethodPrefix}{info.Name}"));

            if (matchingAdditionalParamtersMethod != null)
            {
                sb.AppendLine($"parameters.AddRange(this.{matchingAdditionalParamtersMethod}());");
            }

            if (classAddParams)
            {
                sb.AppendLine($"parameters.AddRange(this.Combined{ClassInfo.AdditionalParamtersForClassMethod}());");
            }

            sb.AppendLine("return parameters;\n}");

            return sb.ToString();
        }

        /// <summary>
        /// Surrounds the input string in quotes.
        /// </summary>
        /// <param name="input">The input string.</param>
        /// <returns>The string, but in quotes.</returns>
        private static string SurroundInQuotes(string input)
        {
            return "\"" + input + "\"";
        }
    }
}

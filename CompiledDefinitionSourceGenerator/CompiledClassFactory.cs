// <copyright file="CompiledClassFactory.cs" company="Tom Luppi">
//     Copyright (c) Tom Luppi.  All rights reserved.
// </copyright>

namespace CompiledDefinitionSourceGenerator
{
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    /// <summary>
    /// Factory which creates the compiled source file.
    /// </summary>
    internal static class CompiledClassFactory
    {
        /// <summary>
        /// The usings in the class.
        /// </summary>
        private const string Usings = @"
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using LegendsGenerator.Contracts;
    using LegendsGenerator.Contracts.Compiler;
    using LegendsGenerator.Contracts.Definitions;
    using LegendsGenerator.Contracts.Definitions.Events;";

        /// <summary>
        /// Generates a comparible Compiled Definition from the class info.
        /// </summary>
        /// <param name="classInfo">The class info to generate.</param>
        /// <returns>The class's C# code.</returns>
        public static string Generate(ClassInfo classInfo)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine($"namespace {classInfo.Namespace}");
            sb.AppendLine("{");
            sb.AppendLine(Usings);
            sb.AppendLine($"{classInfo.Accesibility} partial class {classInfo.TypeName}");
            sb.AppendLine("{");
            sb.AppendLine(FieldDefinitions(classInfo));
            sb.AppendLine(CompileMethod(classInfo));

            foreach (var prop in classInfo.CompiledProps)
            {
                sb.AppendLine(EvalConditionMethod(prop, classInfo.AdditionalParametersForMethods));
            }

            foreach (var prop in classInfo.CompiledProps)
            {
                sb.AppendLine(GetParametersMethod(prop, classInfo.AdditionalParametersForMethods));
            }

            sb.AppendLine("}");
            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Gets the field definitions on this class.
        /// </summary>
        /// <param name="classInfo">The class info.</param>
        /// <returns>All nessesary field definions.</returns>
        private static string FieldDefinitions(ClassInfo classInfo)
        {
            StringBuilder sb = new StringBuilder();

            foreach (var prop in classInfo.CompiledProps)
            {
                sb.AppendLine($"private Lazy<ICompiledCondition<{prop.ReturnType}>> compiledCondition{prop.Name} = ");
                sb.AppendLine($"   new Lazy<ICompiledCondition<{prop.ReturnType}>>(() => this.Compiler.AsSimple<{prop.ReturnType}>(this.{prop.Name}, this.GetParameters{prop.Name}()));");
            }

            return sb.ToString();
        }

        /// <summary>
        /// Creates the method which activates all Lazy fields so compile everything.
        /// </summary>
        /// <param name="classInfo">The class info.</param>
        /// <returns>The method, in string form.</returns>
        private static string CompileMethod(ClassInfo classInfo)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine($"public override void Compile()");
            sb.AppendLine("{");
            sb.AppendLine("base.Compile();");

            foreach (PropertyInfo prop in classInfo.CompiledProps)
            {
                sb.AppendLine($"_ = this.compiledCondition{prop.Name}.Value;");
            }

            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Creates the method which runs the condition evalulate method.
        /// </summary>
        /// <param name="info">The property info.</param>
        /// <param name="additionParameterMethods">The list of additional parameter methods.</param>
        /// <returns>The method, in string form.</returns>
        private static string EvalConditionMethod(PropertyInfo info, IReadOnlyCollection<string> additionParameterMethods)
        {
            string? matchingAdditionalParamtersMethod =
                additionParameterMethods.FirstOrDefault(x => x.Equals($"{ClassInfo.AdditionalParamtersMethodPrefix}{info.Name}"));

            string parametersList = string.Join(", ", info.Variables.Select(v => $"BaseThing {v}"));

            if (matchingAdditionalParamtersMethod != null)
            {
                parametersList += ", IDictionary<string, BaseThing> additionalParameters";
            }

            StringBuilder sb = new StringBuilder();
            sb.AppendLine($"public {info.ReturnType} Eval{info.Name}(Random rdm, {parametersList})");
            sb.AppendLine("{");
            sb.AppendLine(@"IDictionary<string, BaseThing> param = new Dictionary<string, BaseThing>() {");

            foreach (var parameter in info.Variables)
            {
                sb.AppendLine($"{{ {SurroundInQuotes(parameter)}, {parameter} }}");
            }

            sb.AppendLine("};");

            if (matchingAdditionalParamtersMethod != null)
            {
                sb.AppendLine(@"
                    foreach(var additionalParameter in additionalParameters)
                    {
                        param[additionalParameter.Key] = additionalParameter.Value;
                    }");
            }

            sb.AppendLine($"return this.compiledCondition{info.Name}.Value.Evaluate(rdm, param);");
            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Constructs a method which gets the parameters lsit for the specified property.
        /// </summary>
        /// <param name="info">The property info.</param>
        /// <param name="additionParameterMethods">The list of methods which return addition parameter names.</param>
        /// <returns>A method, in string form</returns>
        private static string GetParametersMethod(PropertyInfo info, IReadOnlyCollection<string> additionParameterMethods)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine($"private IList<string> GetParameters{info.Name}()");
            sb.AppendLine("{");
            sb.AppendLine($"List<string> parameters = new List<string> {{ {string.Join(", ", info.Variables.Select(SurroundInQuotes))} }};");

            string? matchingAdditionalParamtersMethod =
                additionParameterMethods.FirstOrDefault(x => x.Equals($"{ClassInfo.AdditionalParamtersMethodPrefix}{info.Name}"));

            if (matchingAdditionalParamtersMethod != null)
            {
                sb.AppendLine($"parameters.AddRange(this.{matchingAdditionalParamtersMethod}());");
            }

            sb.AppendLine("return parameters;\n}");

            return sb.ToString();
        }

        /// <summary>
        /// Surrounds the input string in quotes.
        /// </summary>
        /// <param name="input">The input string.</param>
        /// <returns>The string, but in quotes.</returns>
        private static string SurroundInQuotes(string input)
        {
            return "\"" + input + "\"";
        }
    }
}
